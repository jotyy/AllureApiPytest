[2020-11-26 10:02:38,017][rest_client.py 53][INFO]: 接口请求地址 ==>> https://jotyy.top/crud/api/v1/articles
[2020-11-26 10:02:38,018][rest_client.py 54][INFO]: 接口请求方式 ==>> GET
[2020-11-26 10:02:38,018][rest_client.py 56][INFO]: 接口请求头 ==>> {
    "Authorization": "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdXRob3JpemVkIjp0cnVlLCJleHAiOjE2MDYzODg1NTcsInVzZXJfaWQiOjY1fQ.rV0iHF0HSLAP_PI6A8Ui_OL3TwYz118qcl9wjas81Hs"
}
[2020-11-26 10:02:38,018][rest_client.py 57][INFO]: 接口请求 params 参数 ==>> null
[2020-11-26 10:02:38,018][rest_client.py 58][INFO]: 接口请求体 data 参数 ==>> null
[2020-11-26 10:02:38,018][rest_client.py 59][INFO]: 接口请求体 json 参数 ==>> null
[2020-11-26 10:02:38,019][rest_client.py 60][INFO]: 接口上传附件 files 参数 ==>> None
[2020-11-26 10:02:38,019][rest_client.py 61][INFO]: 接口 cookies 参数 ==>> null
[2020-11-26 10:02:39,455][test_01_get_all_articles.py 19][INFO]: 获取所有文章 ==>> 返回结果 ==>> {"code":0,"msg":"获取文章列表成功","data":[{"ID":5,"CreatedAt":"2016-06-04T14:52:59+08:00","UpdatedAt":"0001-01-01T00:00:00Z","DeletedAt":null,"title":"Android常用布局","cover_url":"https://jotyy.top/images/2.jpg","desc":"在Android中，有5种常见的布局方式。","content":"#一、布局\n\n        在Android中，有五种常见的布局方式。\n\n- FrameLayout（框架布局）\n\n- LinearLayout（线性布局）\n\n- AbsoluteLayout（绝对布局）\n\n- RelativeLayout（相对布局）\n\n- TableLayout（表格布局）\n\n##1. Frame框架布局\n- 特点：放入其中的所有元素都被放置在最左上的区域，而且无法为这些元素指定一个确切的位置，下一个子元素会重叠覆盖上一个子元素\n- 应用场景 ：适合浏览单张图片。\n\n##2.LinearLayout线性布局\n-特点：主要提供控件水平或垂直排列的模型，每一个子组件都是以垂直或水平的方式来线性排列（默认为垂直）。\n-应用场景：最常用的布局方式\n\u003eLinearLayout中有一个重要的属性：android:layout_weight=\"1\"，这个weight代表权重。\n\n##3.Absolute绝对布局\n- 已淘汰不考虑\n\n##4.RelativeLayout相对布局\n- 特点：以某一个组件作为参照物，来定位下一个组件的位置的布局方式\n- 应用场景：适配神器，推荐使用\n\n##5.TableLayout表格布局\n- 特点：使用TableRow布局，其中TableRow代表一行。TableRow中的每一个视图组件代表一个单元格。\n\n#二、布局属性配置\n##1、五种Layout中Item的基础属性\n- layout_width\u0026layout_height\n  设置组件的宽度和高度\n- layout_margin+方位\u0026padding+方位\n 设置组件的外边距和内边距\n- layout_gravity\u0026gravity\n  确定view的位置\n\n##2、各种Layout的特有属性\n###2.1 FrameLayout\n  作为最简单的Layout，只具备基本属性\n\n###2.2 AbsoluteLayout\n  已淘汰，不研究。\n\n###2.3 TableLayout\n  除了基础属性外，还具有一个LinearLayout的属性\n\n###2.4 LinearLayout\n  - orientation\n    设置布局内控件的排列方式\n    vertical  垂直-默认值\n    horizontal  水平\n\n- layout_weight\n  比例分配属性\n  设置权重，按比例分配界面的空间。\n\n###2.5 RelativeLayout\n####a 相对于父空间\n| XML属性        | 说明           |\n| ------------- |:-------------:|\n| layout_alignParent+方位      | 相对于父控件方位对齐 |\n| layout_centerVertical     | 当前父控件的纵向中间位置      |\n| layout_centerHorizontal | 当前父控件的横向中间位置      |  \n| layout_centerInParent | 当前父控件的纵横向中间位置      |      \n\n####b 相对于给定控件\n|XML属性\t| 说明 |\n| ------------- |:-------------:|\n|layout_above\t|使当前控件位于给出id控件的上方|\n|layout_below\t|使当前控件位于给出id控件的下方|\n|layout_toLeftOf\t|使当前控件位于给出id控件的左侧|\n|layout_toRightOf\t|使当前控件位于给出id控件的右侧|\n|layout_alignBottom\t|使当前控件与给出id控件的底部部重合|\n|layout_alignLeft\t|使当前控件与给出id控件的左边重合|\n|layout_alignRight\t|使当前控件与给出id控件的右边重合|\n|layout_alignTop\t|使当前控件与给出id控件的顶部重合|\n|layout_alignBaseline\t|使当前控件的BaseLine与给出id控件t的BaseLine重合|\n例如：\n\u003eandroid:layout_below = \"@+id/tab_imageview\"\n\n##3.选择器selector.xml的属性\n###3.1 作用\n  通过设置selector.xml可以使控件在不同操作下显示不同的样式。\n\n###3.2 属性\n|XML属性\t|说明|\n| ------------- |:-------------:|\n|android:drawable\t|放一个drawable资源|\n|android:state_pressed|\t按下状态，如一个按钮触摸或者点击。|\n|android:state_focused|\t取得焦点状态，比如用户选择了一个文本框。|\n|android:state_hovered\t|光标悬停状态，通常与focused state相同，它是4.0的新特性|\n|android:state_selected\t|选中状态|\n|android:state_enabled\t|能够接受触摸或者点击事件|\n|android:state_checked\t|被checked了，如：一个RadioButton可以被check了。|\n|android:state_enabled\t|能够接受触摸或者点击事件|\n以上属性的取值都是boolean属性。\n\n###3.3 举例说明\n  添加一个button_selector.xml\n```\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\n\u003c selector xmlns:android=\"http://schemas.android.com/apk/res/android\"\u003e\n\n \u003c !-- 指定按钮按下时的图片 --\u003e\n \u003citem android:state_pressed=\"true\"  \n       android:drawable=\"@drawable/start_down\"\n /\u003e\n\n \u003c !-- 指定按钮松开时的图片 --\u003e \n \u003citem android:state_pressed=\"false\"\n       android:drawable=\"@drawable/start\"\n /\u003e\n```\n\n##4.布局形状shape.xml的属性\n```\u003cshape xmlns:android=\"http://schemas.android.com/apk/res/android\"\u003e\n\n//默认颜色\n\u003csolid android:color=\"#876543\"/\u003e\n//哪个方向有边框线\n  \u003cpadding\n        android:bottom=\"0dp\"\n        android:left=\"1dp\"\n        android:right=\"1dp\"\n        android:top=\"1dp\" /\u003e\n     //边框线颜色、大小\n    \u003cstroke\n        android:width=\"1dp\"\n        android:color=\"#000000\" /\u003e\n```","created_by":"Jotyy","modified_by":""},{"ID":6,"CreatedAt":"2016-08-10T14:53:54+08:00","UpdatedAt":"0001-01-01T00:00:00Z","DeletedAt":null,"title":"RxJava基础-----两种基本实现方式","cover_url":"https://jotyy.top/images/3.jpg","desc":"本文我们来讲讲RxJava的两种实现方式。","content":"#RxJava实现方式一：分步骤实现\n步骤：\n           - 1.创建被观察者（Observable）\n           - 2.创建观察者（Observer）\n           - 3.创建订阅连接被观察者与观察者\n##1.创建被观察者（Observable） 生产事件\n\n         // 1. 创建被观察者 Observable 对象\n        Observable\u003cInteger\u003e observable = Observable.create(new ObservableOnSubscribe\u003cInteger\u003e() {\n          // create() 是 RxJava 最基本的创造事件序列的方法\n          // 此处传入了一个 OnSubscribe 对象参数\n          // 当 Observable 被订阅时，OnSubscribe 的 call() 方法会自动被调用，即事件序列就会依照设定依次被触发\n          // 即观察者会依次调用对应事件的复写方法从而响应事件\n          // 从而实现被观察者调用了观察者的回调方法 \u0026 由被观察者向观察者的事件传递，即观察者模式\n\n        // 2. 在复写的subscribe（）里定义需要发送的事件\n            @Override\n            public void subscribe(ObservableEmitter\u003cInteger\u003e emitter) throws Exception {\n                // 通过 ObservableEmitter类对象产生事件并通知观察者\n                // ObservableEmitter类介绍\n                    // a. 定义：事件发射器\n                    // b. 作用：定义需要发送的事件 \u0026 向观察者发送事件\n                emitter.onNext(1);\n                emitter.onNext(2);\n                emitter.onNext(3);\n                emitter.onComplete();\n            }\n        });\n\n###\u003c--扩展：RxJava 提供了其他方法用于 创建被观察者对象Observable --\u003e\n// 方法1：just(T...)：直接将传入的参数依次发送出来\n  Observable observable = Observable.just(\"A\", \"B\", \"C\");\n  // 将会依次调用：\n  // onNext(\"A\");\n  // onNext(\"B\");\n  // onNext(\"C\");\n  // onCompleted();\n\n// 方法2：from(T[]) / from(Iterable\u003c? extends T\u003e) : 将传入的数组 / Iterable 拆分成具体对象后，依次发送出来\n  String[] words = {\"A\", \"B\", \"C\"};\n  Observable observable = Observable.from(words);\n  // 将会依次调用：\n  // onNext(\"A\");\n  // onNext(\"B\");\n  // onNext(\"C\");\n  // onCompleted();\n\n##2.创建观察者（observer） 接收事件\n\n        \u003c--方式1：采用Observer 接口 --\u003e\n        // 1. 创建观察者 （Observer ）对象\n        Observer\u003cInteger\u003e observer = new Observer\u003cInteger\u003e() {\n        // 2. 创建对象时通过对应复写对应事件方法 从而 响应对应事件\n\n            // 观察者接收事件前，默认最先调用复写 onSubscribe（）\n            @Override\n            public void onSubscribe(Disposable d) {\n                Log.d(TAG, \"开始采用subscribe连接\");\n            }\n            \n            // 当被观察者生产Next事件 \u0026 观察者接收到时，会调用该复写方法 进行响应\n            @Override\n            public void onNext(Integer value) {\n                Log.d(TAG, \"对Next事件作出响应\" + value);\n            }\n\n            // 当被观察者生产Error事件\u0026 观察者接收到时，会调用该复写方法 进行响应\n            @Override\n            public void onError(Throwable e) {\n                Log.d(TAG, \"对Error事件作出响应\");\n            }\n          \n            // 当被观察者生产Complete事件\u0026 观察者接收到时，会调用该复写方法 进行响应\n            @Override\n            public void onComplete() {\n                Log.d(TAG, \"对Complete事件作出响应\");\n            }\n        };\n\n      \u003c--方式2：采用Subscriber 抽象类 --\u003e\n      // 说明：Subscriber类 = RxJava 内置的一个实现了 Observer 的抽象类，对       Observer 接口进行了扩展\n\n        // 1. 创建观察者 （Observer ）对象\n        Subscriber\u003cString\u003e subscriber = new Subscriber\u003cInteger\u003e() {\n\n        // 2. 创建对象时通过对应复写对应事件方法 从而 响应对应事件\n            // 观察者接收事件前，默认最先调用复写 onSubscribe（）\n            @Override\n            public void onSubscribe(Subscription s) {\n                Log.d(TAG, \"开始采用subscribe连接\");\n            }\n\n            // 当被观察者生产Next事件 \u0026 观察者接收到时，会调用该复写方法 进行响应\n            @Override\n            public void onNext(Integer value) {\n                Log.d(TAG, \"对Next事件作出响应\" + value);\n            }\n\n            // 当被观察者生产Error事件\u0026 观察者接收到时，会调用该复写方法 进行响应\n            @Override\n            public void onError(Throwable e) {\n                Log.d(TAG, \"对Error事件作出响应\");\n            }\n\n            // 当被观察者生产Complete事件\u0026 观察者接收到时，会调用该复写方法 进行响应\n            @Override\n            public void onComplete() {\n                Log.d(TAG, \"对Complete事件作出响应\");\n            }\n        };\n\n\t\t\n\t\t\n\n#####\u003c--特别注意：2种方法的区别，即Subscriber 抽象类与Observer 接口的区别 --\u003e\n// 相同点：二者基本使用方式完全一致（实质上，在RxJava的 subscribe 过程中，Observer总是会先被转换成Subscriber再使用）\n// 不同点：Subscriber抽象类对 Observer 接口进行了扩展，新增了两个方法：\n    // 1. onStart()：在还未响应事件前调用，用于做一些初始化工作\n    // 2. unsubscribe()：用于取消订阅。在该方法被调用后，观察者将不再接收 \u0026 响应事件\n    // 调用该方法前，先使用 isUnsubscribed() 判断状态，确定被观察者Observable是否还持有观察者Subscriber的引用，如果引用不能及时释放，就会出现内存泄露\n\n\n\t\n##3.创建订阅（subscriber）连接观察者和被观察者\n\n  ```observable.subscribe(observer);\n  或者 observable.subscribe(subscriber)；\t\n```\n \n ```\n\u003c-- Observable.subscribe(Subscriber) 的内部实现 --\u003e\n\npublic Subscription subscribe(Subscriber subscriber) {\n    subscriber.onStart();\n    // 步骤1中 观察者  subscriber抽象类复写的方法，用于初始化工作\n    onSubscribe.call(subscriber);\n    // 通过该调用，从而回调观察者中的对应方法从而响应被观察者生产的事件\n    // 从而实现被观察者调用了观察者的回调方法 \u0026 由被观察者向观察者的事件传递，即观察者模式\n    // 同时也看出：Observable只是生产事件，真正的发送事件是在它被订阅的时候，即当 subscribe() 方法执行时\n}\n```\n#RxJava实现方式二：基于事件流的链式调用\n```\n// RxJava的链式操作\n        Observable.create(new ObservableOnSubscribe\u003cInteger\u003e() {\n        // 1. 创建被观察者 \u0026 生产事件\n            @Override\n            public void subscribe(ObservableEmitter\u003cInteger\u003e emitter) throws Exception {\n                emitter.onNext(1);\n                emitter.onNext(2);\n                emitter.onNext(3);\n                emitter.onComplete();\n            }\n        }).subscribe(new Observer\u003cInteger\u003e() {\n            // 2. 通过通过订阅（subscribe）连接观察者和被观察者\n            // 3. 创建观察者 \u0026 定义响应事件的行为\n            @Override\n            public void onSubscribe(Disposable d) {\n                Log.d(TAG, \"开始采用subscribe连接\");\n            }\n            // 默认最先调用复写的 onSubscribe（）\n\n            @Override\n            public void onNext(Integer value) {\n                Log.d(TAG, \"对Next事件\"+ value +\"作出响应\"  );\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                Log.d(TAG, \"对Error事件作出响应\");\n            }\n\n            @Override\n            public void onComplete() {\n                Log.d(TAG, \"对Complete事件作出响应\");\n            }\n\n        });\n    }\n}\n```","created_by":"Jotyy","modified_by":""},{"ID":8,"CreatedAt":"2017-06-07T14:44:46+08:00","UpdatedAt":"0001-01-01T00:00:00Z","DeletedAt":null,"title":"Android解析Json数据","cover_url":"https://jotyy.top/images/4.jpg","desc":"Json解析是我们处理Api返回数据的必须品","content":"#什么是Json\n  JavaScript Object Notation，JavaScript的对象表示法，是一种轻量级的文本数据交换格式。\n##作用\n  用于数据的标记、存储和传输。\n##特点\n  - 轻量级的文本数据交换格式\n  - 独立于语言和平台，具有广泛性\n  - 具有自我描述性\n  - 读写速度快、解析简单\n##语法\n  Json值\n  - 名称/值\n  - 数组\n  - 对象\n  Json实例\n```\n{\"skill\":{\n  \"web\":[\n  {\n    \"name\":\"android\",\n    \"year\":\"5\"\n  }\n  {\n    \"name\":\"java\",\n    \"year\":\"4\"\n  }\n  {\n    \"name\":\"c++\",\n    \"year\":\"2\"\n  }\n]\n}\n}\n```\n  - “名称、值”\n     无序、一个对象用“｛｝”包括，名称和值间用“：”相隔，对象间用“，”隔开；\n```\n\"name\":\"android\"\n```\n  - 对象\n一个Json对象包括多个名称/值对，在花括号里书写\n```\n{ \"name\":\"html\",\"year\":\"5\"}\n```\n  - 数组\n    数组以“[]”包括，数据的对象用逗号隔开\n```\n             [{\n                \"name\":\"Android\",\n                \"year\":\"5\"\n               },\n               {\n                \"name\":\"java\",\n                \"year\":\"4\"\n              }]\n\n```\n\n\n####总结\n   数组包含对象，对象包含值/对\n\n##Json解析\n   ###解析方法\n   Android解析Json数据的方法和XML的解析类似，主要有两种方式：基于事件驱动和基于文档驱动解析方式。\n   ####基于事件驱动\n   主流方式：Gson解析和Jackson解析\n\n   ####一、Gson解析介绍\n   - 步骤1：创建一个与Json数据对应的JavaBean类（用于存储需要解析的数据）\n          Gson解析的关键是要根据json数据内的结构写出一个对应的JavaBean，规则如下：\n  1.Json的大括号对应一个对象，对象内有key和value值。在JavaBean里面的类属性要和key同名。\n  2.Json的方括号对应一个数组，所以在JavaBean类中对应的也是数组，数据里面可以有值或对象。\n  3.如果数组里面只有值没有key，说明它是一个纯数组，如果有key说明是对象数组。对象数组需要在Bean中建立一个内部类去定义，类属性就是对应的对象里面的key，建立了之后要创建一个这个内部类的对象，名字对应数组名。\n  4.对象里面嵌套对象的时候，也要建立一个内部类，和对象数组一样，这个内部类对象的名字就是父对象的key。\n\nPS：JavaBean类里的属性不一定要全部和Json数据里所有key相同，可以按需取出数据，名字必须对应。Android Studio可以使用Gsonfromat快速创建Bean类。\n\n  ####创建示例\n```\nString json = \"{\\\"id\\\":1,\\\"name\\\":\\\"小明\\\",\\\"sex\\\":\\\"男\\\",\\\"age\\\":18,\\\"height\\\":175}\";\n```\n创建Json类如下：\n```\npublic class EntityStudent {\n    private int id;\n    private String name;\n    private String sex;\n    private int age;\n    private int height;\n\n    public void setId(int id){\n        this.id = id;\n    }\n    public void setName(String name){\n        this.name = name;\n    }\n    public void setSex(String sex){\n        this.sex = sex;\n    }\n    public void setAge(int age){\n        this.age = age;\n    }\n    public void setHeight(int height){\n        this.height = height;\n    }\n    public int getId(){\n        return id;\n    }\n    public String getName(){\n        return name;\n    }\n    public String getSex(){\n        return sex;\n    }\n    public int getAge(){\n        return age;\n    }\n    public int getHeight(){\n        return  height;\n    }\n    public void show(){\n                System.out.print(\"id=\" + id + \",\");\n                System.out.print(\"name=\" + name+\",\");\n                System.out.print(\"sex=\" + sex+\",\");\n                System.out.print(\"age=\" + age+\",\");\n                System.out.println(\"height=\" + height + \",\");\n\n    }\n}\n```\n\n较为复杂的Json数据\n```\n{\"translation\":[\"车\"],\n  \"basic\":\n    {\n      \"phonetic\":\"kɑː\",\n      \"explains\":[\"n. 汽车；车厢\",\"n. (Car)人名；(土)贾尔；(法、西)卡尔；(塞)察尔\"]},\n  \"query\":\"car\",\n  \"errorCode\":0,\n  \"web\":[{\"value\":[\"汽车\",\"车子\",\"小汽车\"],\"key\":\"Car\"},\n         {\"value\":[\"概念车\",\"概念车\",\"概念汽车\"],\"key\":\"concept car\"},\n         {\"value\":[\"碰碰车\",\"碰撞用汽车\",\"碰碰汽车\"],\"key\":\"bumper car\"}]\n}\n```\n创建Bean类如下\n```\nimport java.util.List;\n\npublic class student {\n    public String[] translation;      //[\"车\"]数组\n    public basic basic;                //basic对象里面嵌套着对象，创建一个basic内部类对象\n    public  static class basic{        //建立内部类\n        public String phonetic;\n        public String[] explains;\n    }\n    public String query;\n    public int errorCode;\n    public List\u003cwb\u003e web;            //web是一个对象数组，创建一个web内部类对象\n    public static class wb{            \n            public String[] value;\n            public String key;\n        }\n\n    public void show(){\n        //输出数组\n        for (int i = 0;i\u003ctranslation.length;i++)\n        {\n        System.out.println(translation[i]);\n        }\n        //输出内部类对象\n        System.out.println(basic.phonetic);\n        //输出内部类数组\n        for (int i = 0;i\u003cbasic.explains.length;i++){\n            System.out.println(basic.explains[i]);\n        }\n        System.out.println(query);\n        System.out.println(errorCode);\n        for (int i = 0;i\u003cweb.size();i++){\n            for(int j = 0; j\u003cweb.get(i).value.length;j++)\n            {\n                System.out.println(web.get(i).value[j]);\n            }\n            System.out.println(web.get(i).key);\n        }\n    }\n }\n\n```\n\n  -步骤2：下载并导入Gson所需的库\n  -步骤3：用Gson进行转换\n```\nimport android.os.Bundle;\nimport android.support.v7.app.AppCompatActivity;\nimport com.google.gson.Gson;\n\nimport org.json.JSONArray;\nimport org.json.JSONException;\nimport org.json.JSONObject;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\n\npublic class MainActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        Gson gson = new Gson();\n        //创建JavaBean类的对象\n      Student student = new EntityStudent();\n        String json = \"{\\\"id\\\":1,\\\"name\\\":\\\"小明\\\",\\\"sex\\\":\\\"男\\\",\\\"age\\\":18,\\\"height\\\":175}\";\n       //用GSON方法将JSON数据转为单个类实体\n        student = gson.fromJson(json,Student.class);\n       //调用student方法展示解析的数据\n        student.show();\n      //将Java集合转换为json\n        String json2 = gson.toJson(List);        System.out.println(json2);\n    }\n}\n```\n利用Gson方法解析，关键在于根据Json数据里面的结构写出一个对应的JavaBean类，而解析的过程只需要：\n```\nJavaBean对象 = gson.fromJson(son,javaBean类类名.class);\n```\n\n####二、Jackson解析\n- 原理：基于事件驱动，与Gson相同，先创建一个对应于Json数据的JavaBean类就可以通过简单的操作解析出所需的Json数据。但和Gson不同的是，Gson可以按需解析，但Jackson必须全部解析一一对应，但解析速度和效率都比Gson高。\n  -核心代码\nJSON数据\n```\n{\"student\":\n          [\n           {\"id\":1,\"name\":\"小明\",\"sex\":\"男\",\"age\":18,\"height\":175,\"date\":[2013,8,11]},\n           {\"id\":2,\"name\":\"小红\",\"sex\":\"女\",\"age\":19,\"height\":165,\"date\":[2013,8,23]},\n           {\"id\":3,\"name\":\"小强\",\"sex\":\"男\",\"age\":20,\"height\":185,\"date\":[2013,9,1]}\n          ],\n  \"grade\":\"2\"\n}\n```\n步骤1：建立对应的javaBean：\n\n建立javaBean的对应规则和GSON一样\n\n```\nimport java.util.ArrayList;\nimport java.util.List;\nclass test {\n    private  List\u003cstu\u003e student = new ArrayList\u003cstu\u003e();\n\n    private  int grade;\n\n    public void setStudent(List\u003cstu\u003e student){\n        this.student = student;\n    }\n    public List\u003cstu\u003e getStudent(){\n        return student;\n    }\n    public void setGrade(int grade){\n        this.grade = grade;\n    }\n    public int getGrade(){\n        return grade;\n    }\n    private static class stu {\n        private  int id;\n        private  String name;\n        private  String sex;\n        private  int age;\n        private  int height;\n        private  int[] date;\n\n        public void setId(int id){\n            this.id = id;\n        }\n        public int getId(){\n            return id;\n        }\n        public void setName(String name){\n            this.name = name;\n        }\n        public String getName(){\n            return  name;\n        }\n        public void setSex(String sex){\n            this.sex = sex;\n        }\n        public String getSex(){\n            return sex;\n        }\n        public void  setAge(int age){\n            this.age = age;\n        }\n        public int getAge(){\n            return age;\n        }\n        public void setHeight(int height){\n            this.height = height;\n        }\n        public int getHeight(){\n            return height;\n        }\n        public void setDate(int[] date){\n            this.date = date;\n        }\n        public int[] getDate(){\n            return date;\n        }\n    }\n\n    public String tostring(){\n        String str = \"\";\n        for (int i = 0;i\u003cstudent.size();i++){\n            str += student.get(i).getId() + \" \" + student.get(i).getName() + \" \" + student.get(i).getSex() + \" \" + student.get(i).getAge() + \" \" + student.get(i).getHeight() ;\n            for (int j = 0;j\u003cstudent.get(i).getDate().length;j++) {\n                str += student.get(i).getDate()[j]+ \" \" ;\n            }\n            str += \"\\n\";\n        }\n        str += \"\\n\"+getGrade();\n        return str;\n    }\n}\n```\n步骤2：利用Jackson方法进行解析\n```\nimport android.os.Bundle;\nimport android.support.v7.app.AppCompatActivity;\nimport org.codehaus.jackson.map.ObjectMapper;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n\npublic class MainActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        ObjectMapper objectMapper = new ObjectMapper();\n        try {\n            InputStreamReader isr = new InputStreamReader(this.getClass().getClassLoader().getResourceAsStream(\"assets/\" + \"student.json\"),\"utf-8\");\n            //从assets获取json文件\n            BufferedReader bfr = new BufferedReader(isr);\n            String line;\n            StringBuilder stringBuilder = new StringBuilder();\n            while ((line = bfr.readLine())!=null){\n                stringBuilder.append(line);\n            }//将JSON数据转化为字符串\n            System.out.println(stringBuilder.toString());\n            System.out.println(tes.tostring());\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n    }\n\n\n}\n```\n\n###基于文档驱动解析方式\n- 主流方式：Android Studio自带的org.json解析\n- 解析方式：基于文档驱动，类似于XML的DOM解析方法，先把全部文件读入到内存中，然后遍历所有数据，然后根据需要检索想要的数据。\n\n需要解析的JSON数据：\n```\n{\n\"student\":[\n               {\"id\":1,\"name\":\"小明\",\"sex\":\"男\",\"age\":18,\"height\":175},\n              {\"id\":2,\"name\":\"小红\",\"sex\":\"女\",\"age\":19,\"height\":165},\n               {\"id\":3,\"name\":\"小强\",\"sex\":\"男\",\"age\":20,\"height\":185}\n            ],\n\"cat\":\"it\"\n}\n```\n读入本地assets文件夹里面的student.son并解析\n\n```\nimport android.os.Bundle;\nimport org.json.JSONArray;\nimport org.json.JSONException;\nimport org.json.JSONObject;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\n\npublic class MainActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        EntityStudent student = new EntityStudent();\n\n\n        try {\n            //从assets获取json文件\n            InputStreamReader isr = new InputStreamReader(this.getClass().getClassLoader().getResourceAsStream(\"assets/\" + \"student.json\"));\n            //字节流转字符流\n           BufferedReader bfr = new BufferedReader(isr);\n            String line ;\n            StringBuilder stringBuilder = new StringBuilder();\n            while ((line = bfr.readLine())!=null){\n                stringBuilder.append(line);\n            }//将JSON数据转化为字符串\n            JSONObject root = new JSONObject(stringBuilder.toString());\n            //根据键名获取键值信息\n            System.out.println(\"root:\"+root.getString(\"cat\"));\n            JSONArray array = root.getJSONArray(\"student\");\n            for (int i = 0;i \u003c array.length();i++)\n            {\n                JSONObject stud = array.getJSONObject(i);\n                System.out.println(\"------------------\");\n                System.out.print(\"id=\"+stud.getInt(\"id\")+ \",\"));\n                System.out.print(\"name=\"+stud.getString(\"name\")+ \",\"));\n                System.out.print(\"sex=\"+stud.getString(\"sex\")+ \",\"));\n                System.out.print(\"age=\"+stud.getInt(\"age\")+ \",\"));\n                System.out.println(\"height=\"+stud.getInt(\"height\")+ \",\"));\n                bfr.close();\n                    isr.close();\n                is.close();//依次关闭流\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (JSONException e) {\n            e.printStackTrace();\n        }\n\n    }\n}\n```\n\n\n##GSON、Jackson、Android Studio自带org.son解析三类方式对比\n\n###Android Studio自带org.json\n\n-原理：基于文档驱动\n-特点：\n-优点：无\n-缺点：解析 XML 文件时会将整个 XML 文件的内容解析成树型结构存放在内存中并创建新对象，比较消耗时间和内存,解析速度和效率慢，解析方式和性能完败GSON\n####GSON方式\n\n-原理：基于事件驱动\n-特点：\n-优点：解析方法简单、解析效率高、占存-少、灵活性高\n-使用情境\n适用于需要处理大型 JSON文档、JSON文档结构复杂的场合\n####Jackson方式\n\n-原理：基于事件驱动\n-特点：\n-优点：解析效率最高、在数据量大的情况优势尤为明显、占存少\n-缺点：必须完全解析文档，如果要按需解析的话可以拆分Json来读取，操作和解析方法复杂；\n-使用情境\n适用于需要处理超大型JSON文档、不需要对JSON文档进行按需解析、、性能要求较高的场合\n###与XML解析对比\n\n对于同样作为主流的数据交换格式来说，JSON相比于XML，JSON文档大小更加小，解析方法更加简单、读写速度更快，所以JSON一定是你在数据交换格式的选型中的首选。","created_by":"Jotyy","modified_by":""},{"ID":9,"CreatedAt":"2019-02-12T14:41:45+08:00","UpdatedAt":"0001-01-01T00:00:00Z","DeletedAt":null,"title":"深入学习Java NIO","cover_url":"https://jotyy.top/images/5.jpg","desc":"什么是NIO？","content":"## 一、概念\n\nNIO可以称为面向块或缓冲区编程。\n\n### 1.1 NIO包含三个核心组件：\n\n- Channel\n- Buffer\n- Selector\n\n### 1.2 通道和缓冲区（Channel和Buffer）\n\n通常来说NIO中的所有IO都是从Channel开始的。Channel类似于java.io中的流（Stream），通过Channel我们可以把数据写到Buffer中，也可以把数据冲Buffer写入Channel。\n\n所有数据读写都是通过Buffer进行的，永远不会出现直接向Channel写入数据或直接从Channel读取数据的情况。与Stream不同的是，Channel是双向的，Channel打开后就可以直接进行读写。\n\n### 1.3 选择器（Selector）\n\n选择器允许单线程操作多个通道。如果一个程序由大量的连接，同时每个连接 的带宽不高的话，这个特性将会非常有帮助。下面是一个单线程中的Selector维护3个Channel的示意图。\n\n![http://tutorials.jenkov.com/images/java-nio/overview-selectors.png](http://tutorials.jenkov.com/images/java-nio/overview-selectors.png)\n\n要使用Selector的话，我们必须把Channel注册到Selector上，然后就可以调用Selector的select()方法。这个方法会进入阻塞，知道由一个channel符合条件。当方法返回后，线程可以处理这些事件。\n\n## 二、Channel 通道\n\nJava NIO中，Channel和流非常相似，但它们主要有以下几点区别：\n\n1.通道可以读，也可以写，流一般来说是单向的。\n\n2.通道可以异步读写。\n\n3.通道总是基于换成去Buffer来读写。\n\n### 2.1 Channel的实现\n\nJava NIO中Channel主要有以下几种实现：\n\n- FileChannel：主要用于数据读写\n- DatagramChannel：用于UDP 的数据读写\n- SocketChannel：用于TCP的数据读写\n- ServerSocketChannel：允许我们监听TCP 的连接请求，每个请求会创建一个SocketChannel\n\n### 2.2 Channel基础示例\n\n利用FileChannel读取数据到Buffer的例子：\n\n```java\nRandomAccessFile aFile = new RandomAccessFile(\"data/nio-data.txt\",\"rw\");\nFileChannel inChannel = aFile.getChannel();\n\nByteBuffer buf = ByteBuffer.allocate(48);\n\nint bytesRead = inChannel.read(buf);\n\nwhile(bytesRead != -1){\n    System.out.println(\"Read \" + bytesRead);\n    buf.flip();\n    \n    while(buf.hasRemaining()){\n        System.out.print((char) buf.get());\n    }\n    \n    buf.clear();\n    bytesRead = inChannel.read(buf);\n}\naFile.close();\n```\n\n## 三、Buffer 缓冲区\n\nBuffer本质上就是一块内存区，可以用来写入数据，并在稍后读取出来。这块内存被NIO Buffer包裹起来，对外提供一系列方便开发的接口。\n\n### 3.1 Buffer基本用法\n\n利用Buffer读写数据，通常遵循四个步骤：\n\n- 把数据写入Buffer\n- 调用flip()方法\n- 从Buffer中读取数据\n- 调用buffer.clear()或buffer.compat()\n\n当写入数据到buffer中时，buffer会记录已经写入的数据大小。当需要读取数据时，通过flip()方法把buffer从写模式调整为读模式；在读模式下，可以读取所有已写入的数据。\n\n当读取完数据后，需要清空buffer，以满足后续的写入操作。清空buffer有两种方式：调用clear()或compact()方法。clear会清空整个buffer，而compact只会清空已读取的数据，未被读取的数据会被移动到buffer开始的位置，写入位置则紧跟着未读数据之后。\n\n### 3.2 Buffer简单示例\n\n```java\n        RandomAccessFile file = new RandomAccessFile(\"NioTest2.txt\", \"rw\");\n        FileChannel channel = file.getChannel();\n\n        ByteBuffer buffer = ByteBuffer.allocate(48);\n        int bytesRead = channel.read(buffer);\n\n        while (bytesRead != -1) {\n            buffer.flip();\n\n            while (buffer.hasRemaining()) {\n                System.out.print((char) buffer.get());\n            }\n\n            buffer.clear();\n            bytesRead = channel.read(buffer);\n        }\n        file.close();\n```\n\n### 3.3 Buffer的三个属性（capacity，position，limit）\n\n一个Buffer具有三个属性：\n\n- capacity：容量\n- position：位置\n- limit：限制\n\nposition和limit的含义取决于当前buffer所处的模式。capacity在两种模式下都表示容量。\n\n![buffers-modes.png](http://tutorials.jenkov.com/images/java-nio/buffers-modes.png)\n\n#### 3.3.1 容量（capacity）\n\n作为一块内存，buffer有一个固定的大小，叫做capacity（容量）。也就是最多能写入容量值的字节、整型等数据。一旦buffer写满就需要清空已读数据以便下次写入新数据。\n\n#### 3.3.2 位置（position）\n\n当写入数据到Buffer时，需要从一个确定的位置开始，默认初始化时这个位置position为0，一旦写入了数据，比如一个字节，那么position的值就会指向数据之后的一个单元，position最大可以到capacity-1。\n\n当从Buffer读取数据时，也需要从一个确定的位置开始。buffer从写模式切换成读模式时，position会归零，每次读取后，position会向后移动。\n\n#### 3.3.3 上限（limit）\n\n在写模式，limit的含义是我们最大能写入的数据量，等同于Buffer的容量。\n\n在读模式，limit代表我们最大能读取的数据量，等同于写模式下position的位置。\n\n### 3.4 Buffer的类型\n\nJava NIO中有以下具体的Buffer类型：\n\n- ByteBuffer\n- MappedByteBuffer\n- CharBuffer\n- DoubleBuffer\n- FloatBuffer\n- IntBuffer\n- LongBuffer\n- ShortBuffer\n\n### 3.5 Buffer 的一些方法\n\n#### 翻转（flip）\n\nflip()方法可以把Buffer从写模式切换到读模式。调用flip方法会把position归零，并设置limit为之前的position的值。\n\n#### rewind()\n\nrewind()方法将position设置为0，这样我们可以重复读取buffer中的数据，limit则保持不变。\n\n#### clear()和compact()\n\n一旦我们从buffer中读取完数据，需要服用buffer为下次写数据做准备。只需要调用clear或compact方法。\n\n#### mark()和reset()\n\n通过mark方法可以标记当前的position，通过reset可以恢复mark所标记的位置。\n\n#### equals() and compareTo()\n\n可以用eqauls和compareTo比较两个buffer\n\n##### equals()\n\n判断两个buffer相对，需满足：\n\n- 类型相同\n- buffer中剩余字节数相同\n- 所有剩余字节相等\n\n从上面的三个条件可以看出，equals只比较buffer中的部分内容，并不会去比较每一个元素。\n\n##### compareTo()\n\ncompareTo也是比较buffer中的剩余元素，只不过这个方法适用于比较排序的：\n\n## 四、Scatter与Gather\n\nJava NIO在发布时内置了对scatter/gather的支持。scatter/gather是通过通道读写数据的两个概念。\n\nScattering read是指从通道读取的操作能把数据写入多个buffer，也就是sactter代表了数据从一个channel到多个buffer的过程。\n\ngethering write表示从多个buffer把数据写入到一个channel中。\n\nScatter/Gather在某些场景下非常有用，比如需要处理多份分开传输的数据。举例来说，假设一个消息包含了header和body，我们可能会把header和body保存在不同独立buffer中，这种分开处理header与body的做法会使开发更简明。\n\n### 4.1 Scattering Read\n\n![scatter.png](http://tutorials.jenkov.com/images/java-nio/scatter.png)\n\n```java\nByteBuffer header = ByteBuffer.allocate(128);\nByteBuffer body = ByteBuffer.allocate(1024);\n\nByteBuffer[] bufferArray = {header, body};\n\nchannel.read(bufferArray);\n```\n\n我们把多个buffer写在了数组中，然后把数据传递给channel.read()方法，read()方法内部会负责把数据按顺序吸入传进的buffer数组内。一个buffer写满后，接着写到下一个buffer中。\n\n实际上，scattering read内部必须写满一个buffer后才会向后移动到下一个buffer，因此这并不适合消息大小会动态改变的部分，也就是说，如果你有一个header和body，并且header有一个固定的大小（比如128字节）,这种情形下可以正常工作。\n\n### 4.2 Gathering Write\n\n![gather.png](http://tutorials.jenkov.com/images/java-nio/gather.png)\n\n```java\nByteBuffer header = ByteBuffer.allocate(128);\nByteBuffer body = ByteBuffer.allocate(1024);\n\nByteBuffer[] bufferArray = {header, body};\n\nchannel.write(bufferArray);\n```\n\n类似的传入一个buffer数据给write，内部就会按顺序将数据的内容写进channel，这时要注意，写入时候针对的时buffer中position到limit之间的数据。也就是说，如果buffer的容量时128字节，但他只包含了50字节，那么写入的时候只有50字节会真正写入。\n\n因此gathering write是可以适用于可变大小的message的，这和scattering reads不同。\n\n## 五、Channel to Channel Transfer 管道传输接口\n\n在Java NIO中，如果一个channel时FileChannel类型的，那么它可以直接把数据传输到另一个Channel。这个特性得益于FileChannel中的transferTo()和transferFrom()方法。\n\n### 5.1 transferFrom()\n\ntransferFrom()方法把数据从通道源传输到FileChannel：","created_by":"Jotyy","modified_by":""},{"ID":10,"CreatedAt":"2019-05-07T14:17:19+08:00","UpdatedAt":"0001-01-01T00:00:00Z","DeletedAt":null,"title":"Android MVVM——Room实现数据存储底层 ","cover_url":"https://jotyy.top/images/4.jpg","desc":"带你走进Android Room的使用","content":"## 存储模式\n\n在开发移动应用程序的许多情况下，我们还需要提供对数据的脱机访问。想象一下，我们正在开发一个新闻阅读类APP，并且您还希望您的用户可以在他们乘坐飞机时或者他们在没有互联网访问的任何区域访问数据。在某些情况下，您希望显示存储的数据，同时从API加载新数据。如果从应用程序开始就没有在体系结构中实现或考虑这一点，这可能会成为一项复杂的任务，并且可能需要进行大量更改，这也会影响UI层，为新的潜在错误留出空间在你的代码。存储模式正好解决了这个问题，我们从应用程序的开头实现了它。\n\n## 为什么使用数据存储模式？\n\n- 将应用程序与数据源分离\n- 提供来自多个源（DB，API）的数据\n- 隔离数据层\n- 集中，一致的数据访问方式\n- 通过单元测试可测试业务逻辑\n- 很容易增加新数据源\n\n## 如何使用数据库\n\n在Android中，我们有很多操作数据库的库：\n\n- 原生SQLite（太多的样板代码）\n- Realm(太复杂了，我们不需要它的大部分功能)\n- GreenDao(非常好用的ORM)\n- Room（Google官方支持的新的ORM框架）\n\n这个例子里面，我准备使用Room来演示。\n\n## Room 的一些特点\n\n1. **编译时 sql 语句检查**。相信大家都有过 app 跑起来，执行到 db 语句的时候 crash，检查之后发现原来是 sql 语句少了一个 `)` 或者其它符号之类的经历。Room 会在编译阶段检查你的 DAO 中的 sql 语句，如果写错了（包括 sql 语法错误跟表名、字段名等等错误），会直接编译失败并提醒你哪里不对。\n2. **sql 查询直接关联到 Java 对象**。这个应该不用详细解释了，虽然很多第三方 db 库早已经实现。\n3. **耗时操作主动要求异步处理**。这一点还是挺值得注意的，Room 会在执行 db 操作时判断是不是在 UI 线程，比如当你需要插入一条记录到数据库时，Room 会让你放到异步线程去做，否则会直接 crash 掉 app 来告诉你不这样做容易阻塞 UI 线程。虽说死相难看了点（个人觉得打个警告不就完了么?），但对于开发者开发出高质量的应用还是有帮助的。\n4. **基于注解编译时自动生成代码**。这个应该算是 Room 工作原理的核心所在了，你要写的代码之所以这么少，说白了还不是因为 Google 给你写好了很多？希望以后有时间能写一篇源码分析出来，那个时候再讲吧。\n5. **API 设计符合 Sql 标准**。方便扩展进行各种 db 操作。\n\n## Room的使用\n\n首先创建User的数据类，使用@Entity注解建表。\n\n```kotlin\n@Entity(tableName = \"users\")\ndata class User(\n\t@PrimaryKey\n\t@ColumnInfo(name = \"email\")\n\tval email: String,\n\t\n\t@ColumnInfo(name = \"name\")\n\tval name: String\n)\n```\n\n现在我们要声明数据库和UserDao。\n\n```kotlin\n@DataBase(entities = [User::class], version = 1)\nabstract class AppDataBase: RoomDataBase(){\n    abstract fun userDao():UserDao\n}\n\n@Dao\ninterface UserDao{\n    @Query(\"SELCET * FROM users\")\n    fun getUsers(): Single\u003cList\u003cUser\u003e\u003e\n    \n    @Insert(onConfilct = OnConflictStrategy.REPLACE)\n    fun insert(user: User)\n    \n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    fun insertAll(users: List\u003cUser\u003e)\n}\n```\n\n接下来，我们使用Room来创建数据库（通常在项目中会使用Dagger依赖注入的方式）。\n\n```kotlin\nval appDataBase = Room.databaseBuilder(applicationContext,\n                                      AppDataBase::class.java,\"mvvm-database\").builde()\n\nval userDao = appDatabase.userDao()\n```\n\n可以看得出来，使用Room相比其它的数据库框架还是非常非常简单的。现在我们可以对我们的UserRepository进行改造了，加入DataBase数据源。\n\n```kotlin\nclass UserRepository(val userApi: UserApi, val userDao: UserDao){\n    fun getUsers(): Observable\u003cList\u003cUser\u003e\u003e{\n        return Observable.concatArray(\n        \tgetUsersFromDb(),\n            getUsersFromApi()\n        )\n    }\n    \n    fun getUsersFromDb(): Observabel\u003cList\u003cUser\u003e\u003e{\n        return userDao.getUsers().filter { it.isNotEmpty() }\n        \t.toObservable()\n        \t.doOnNext{\n                //获取数据成功\n            }\n    }\n    \n    fun getUserFromApi(): Observable\u003cList\u003cUser\u003e\u003e{\n        return userApi.getUsers()\n        \t.doOnNext{\n                ...\n                storeUsersInDb(it)\n            }\n    }\n    \n    fun storeUserInDb(users: List\u003cUser\u003e){\n        Observable.fromCallable{ userDao.insertAll(users) }\n        \t.subscribeOn(Schedulers.io())\n        \t.observeOn(Schedulers.io())\n        \t.subscribe {\n                //保存成功\n            }\n    }\n}\n```\n\n我们使用Observable.concatArray（）并传递我们的2个源，即DB和API Observables。这将首先向用户提供来自DB的数据，其次是来自API的数据。当从API接收数据时，我们还在doOnNext（）内部触发异步操作以将数据存储在我们的DB中。\n\n可以看到，我们非常简单的实现了一系列的数据存储操作，并且完全与View层脱离了关系。","created_by":"Jotyy","modified_by":""},{"ID":11,"CreatedAt":"2019-06-04T14:05:42+08:00","UpdatedAt":"0001-01-01T00:00:00Z","DeletedAt":null,"title":"Android MVVM ——Using Kotlin and RX实现ViewModel与Model","cover_url":"https://jotyy.top/images/3.jpg","desc":"","content":"随着对公司现有MVP架构模式代码的逐渐不满，每每新增一个小功能，总要在一个又一个的接口中新增方法，代码变得越来越不清晰，迭代变得越来越困难。作为一个爱搞事的程序猿，免不了要考虑一波新的架构模式，MVVM也就映入眼帘。首先对比一下我们曾经的MVP和即将要使用的MVVM吧（MVC就离开历史舞台吧）。\n\n### 为什么要淘汰MVP？\n\n- 太多的接口，一个功能处处接口\n- Presenter层与View层耦合严重\n- View层的一个改变往往牵动Presenter层，增加一个新方法往往要修改好几处地方\n- 每个Presenter无法重用，通常耦合到特定的View层\n\n### MVVM有什么优势？\n\n- 不再有过多的接口\n- ViewModel和DataModel支持单元测试\n- ViewModel不再与特定的View耦合\n- ViewModel可以在多个View中组合或使用\n\n### MVVM到底长什么样？\n\n![](http://www.jotyy.top/upload/20190604_14124166.png)\n\n#### View：\n\n\u003e Activity/Fragment/View\n\u003e\n\u003e 从ViewModel层获取UI数据\n\u003e\n\u003e 请求ViewModel对数据进行操作\n\n#### ViewModel：\n\n\u003e 作为View和Model之间的桥梁\n\u003e\n\u003e 请求Model层的数据并为View层转换\n\u003e\n\u003e 使View层更新数据\n\n#### Model：\n\n\u003e 作为DataModel/Repository\n\u003e\n\u003e 持久化业务逻辑\n\u003e\n\u003e 从多种数据源获取数据（DataBase，REST Api，cache）\n\n------\n\n### 实际使用\n\n这一篇中，我不打算使用LiveData，LiveData在接下来的学习中我们会使用，而且将会相当的给力。先试试RX来实现数据Observe吧。\n\n#### 基本实现\n\n下面这个例子，将会简单的从API请求用户信息列表并显示。\n\n```kotlin\n/** ViewModel */\nclass UserListViewModel(val userRepository: UserRepository){\n    \n    fun getUsers(): Observable\u003cUserList\u003e {\n        //获取用户数据\n        return userRepository.getUser()\n        \t.map { UserList(it, \"Uses loaded success.\") }\n    }\n    \n}\n\n/** Model */\nclass UserRepository(val userApi: UserApi){\n    \n    fun getUsers(): Observable\u003cList\u003cUser\u003e\u003e = \n    \tuserApi.getUsers()\n    \n}\n\ninterface UserApi{\n    \n    @GET(\"users\")\n    fun getUsers(): Observabel\u003cList\u003cUser\u003e\u003e\n    \n}\n```\n\n**UserListViewModle:** ViewModel层，从Repository中获取数据，提供给View\n\n**UserRepository：** 用户数据仓库，从数据库、网路Api获取数据\n\n**UserApi：** 网路接口\n\n#### 改进Model层\n\n我们可以修改**UserRepository**使它可以存储从API请求到的用户列表，这样每次我们调用getUser()方法中，我们会立即先返回缓存的用户列表，然后再返回API中的新数据。这可以使用RX中的**mergeWith()**方法来实现\n\n```kotlin\nclass UserRepository(val userApi: UserApi){\n    \n    var cacheUsers = emptyList\u003cUser\u003e()\n    \n    fun getUsers(): Observale\u003cList\u003cUser\u003e\u003e = \n        if (cachedUsers.isEmpty())\n        \tuserApi.getUsers().doOnNext{ cachedUsers = it }\n        else \n        \tObservable.just(cachedUsers)\n    \t\t\t.mergeWith(userApi.getUsers())\n    \t\t\t.doOnNext{ cachedUsers = it }\n\n}\n```\n\n(PS: 通常在项目中，我们都会使用Dagger来提供UserRepository、UserApi的单例)\n\n#### 好处\n\n这种方法中（将ViewModel与DataModel / Repository分开），ViewModel层不知道，也不关心数据的来源。它也不负责缓存或存储数据。我们能够在不对ViewModel进行任何更改的情况下引入API数据的缓存。\n\n#### 对UserRepository单元测试\n\n我们可以使用TestObserver对UserRepository进行单元测试\n\n```kotlin\nclass UserRepositoryTest{\n    \n    lateinit var userRepository: UserRepository\n\tlateinit var userApi: UserApi\n    \n    @Before\n    fun setUp(){\n        userApi = mock()\n        userRepository = UserRepository(userApi)\n    }\n    \n    @Test\n    fun test_emptyCache_noDataOnApi_returnEmptyList(){\n        `when`(userApi.getUsers()).thenReturn(Observable.just(emptyList\u003cUser\u003e()))\n        \n        userRepository.getUsers().test()\n        \t.assertValue{ it.isEmpty() }\n\n    }\n    \n    @Test\n    fun test_emptyCache_hasDataOnApi_returnsApiData() {\n        `when`(userApi.getUsers()).thenReturn(Observable.just(listOf(aRandomUser())))\n\n        userRepository.getUsers().test()\n                .assertValueCount(1)\n                .assertValue { it.size == 1 }\n    }\n\n    @Test\n    fun test_hasCacheData_hasApiData_returnsBothData() {\n        val cachedData = listOf(aRandomUser())\n        val apiData = listOf(aRandomUser(), aRandomUser())\n        `when`(userApi.getUsers()).thenReturn(Observable.just(apiData))\n        userRepository.cachedUsers = cachedData\n\n        userRepository.getUsers().test()\n                //Both cached \u0026 API data delivered\n                .assertValueCount(2)\n                //First cache data delivered\n                .assertValueAt(0, { it == cachedData })\n                //Secondly api data delivered\n                .assertValueAt(1, { it == apiData })\n    }\n\n    @Test\n    fun test_cache_updatedWithApiData() {\n        val apiData = listOf(aRandomUser(), aRandomUser())\n        `when`(userApi.getUsers()).thenReturn(Observable.just(apiData))\n\n        userRepository.getUsers().test()\n\n        assertEquals(userRepository.cachedUsers, apiData)\n    }\n\n    fun aRandomUser() = User(\"mail@test.com\", \"John\", UUID.randomUUID().toString().take(5))\n\t}\n}\n```\n\n### 总结\n\n这只是我个人对Android中MVVM当前状态和新架构组件的看法。选择适合自己需求的架构，适合自己的团队结构，保持代码清洁，帮助您轻松测试代码，最重要的是允许您轻松添加新功能。","created_by":"Jotyy","modified_by":""},{"ID":14,"CreatedAt":"2019-06-28T09:56:45+08:00","UpdatedAt":"0001-01-01T00:00:00Z","DeletedAt":null,"title":"Android进阶：自定义View基础","cover_url":"https://jotyy.top/images/2.jpg","desc":"","content":"# 一、绘制基础\n\n- 自定义绘制的方式是重写绘制方法，最常用的是onDraw()\n- 绘制的关键是使用Canvas\n    - Canvas的绘制类方法：drawXXX() 关键参数是Paint\n    - Canvas的辅助类方法：范围裁切和几何变换\n- 可以使用不同的绘制方法来控制遮盖关系\n\n## 1.1 如何学习自定义View\n\n### 1. Canvas的drawXXX()系列方法和Paint的常见使用\n\n需要学会的点是使用Paint如何绘制基本图形、如何绘制文字、颜色等。\n\n### 2.Paint的熟练使用\n\n### 3.Canvas对绘制的辅助——范围裁切和几何变换\n\n### 4.使用不同的绘制方法来控制绘制顺序\n\n## 1.2 从onDraw()开始\n\n自定义绘制上手步骤：提前创建好Paint对象，重写onDraw()，把绘制代码写在onDraw里面，就是自定义View最基本的实现。比如：\n\n    val paint = Paint()\n    \n    override fun onDraw(canvas: Canvas){\n    \tsuper.onDraw(canvas)\n    \t\n    \t//绘制一个圆\n    \tcanvas.drawCircle(300,300,200,paint)\n    }\n\n## 1.3 Canvas.drawXXX()和Paint\n\ndrawXXX()方法和Paint掌握之后，就可以应对简单的绘制需求了。主要有以下几点：\n\n### 1. Canvas类下所有drawXXX()方法的熟悉，常用的有drawCircle()、drawBitmap()等\n\n### 2. Paint类的几个最常用方法：\n\n- Paint.setStyle(style: Style) 设置绘制模式\n- Paint.setColor(color: Int) 设置颜色\n- Paint.setStrokeWidth(width: Float) 设置线条宽度\n- Paint.setTextSize(textSize: Float) 设置文字大小\n- Paint.setAntiAlias(aa: Boolean) 设置抗锯齿开关\n\n## 1.4   一些点\n\n1. Paint.setColor(color: Int)\n\n    我们需要画一个红色的圆，需要先把画笔设置成红色。\n\n        paint.setColor(Color.RED)\n        canvas.drawCircle(300,300,200,paint)\n\n2. Paint.setStyle\n\n    如果我们想绘制一个空心圆，可以把绘制模式style设置为画线模式。\n\n        paint.setStyle(Paint.Style.STROKE)\n        canvas.drawCircle(300,300,200,paint)\n\n    style具体有三种：FILL，STROKE和FILL_AND_STROKE，分别是填充模式、画线模式和画线填充模式。默认是FILL。\n\n3. Paint.setStrokeWidth(width: Float)\n\n    在STROKE和FILL_AND_STROKE模式下，还可以使用setStrokeWidth()来设置线条宽度。\n\n4. 抗锯齿\n开启抗锯齿可以使文字和图形的边缘更加平滑\nval paint = Paint(Paint.ANTI_ALIAS_FLAG)","created_by":"Jotyy","modified_by":""},{"ID":16,"CreatedAt":"2019-07-10T15:00:58+08:00","UpdatedAt":"0001-01-01T00:00:00Z","DeletedAt":null,"title":"Android Kotlin协程","cover_url":"https://jotyy.top/images/3.jpg","desc":"","content":"![](http://www.jotyy.top/upload/20190710_15002475.png)\n\n[TOC]\n\n## 一、如何使用协程\n\n## 1.1 添加依赖\n\n```gro\nimplementation \n'org.jetbrains.kotlinx:kotlinx-coroutines-core:1.0.0'\nimplementation \n'org.jetbrains.kotlinx:kotlinx-coroutines-android:1.0.0'\n```\n\n## 1.2 使用协程Coroutine\n\n在kotlinx.coroutines包中，你可以使用launch或async启动一个协程。从概念上讲，async就像launch一样，它启动一个单独的协程，协程相当于一个轻量级的线程，与其他所有的协同程序同时工作。\n\nasync和launch不同的地方在于，launch返回一个Job并且不携带任何结果值，而async返回Deffered。\n\nDeffered表示一个轻量级的非阻塞未来，表示稍后提供结果的承诺。我们可以使用await()方法获取一个deffered的返回结果。Deffered本质上也是Job，因此可以在需要的时候取消它。\n\n\u003e 如果在launch中的代码因为异常而终止，那么它会被是为线程中未捕获异常而导致应用崩溃。异步代码中未捕获异常存储在生成的Deffered中，并且不会在其他任何地方传递，除非经过处理，否则它会被静默删除。\n\n### 协程分发\n\n在Android中，我们常用的又两个分发器dispatcher：\n\n- uiDispatcher：将执行分发到Android主UI线程（用于父协程）\n- bgDispatcher：在后台线程中调度执行（用于子协程）\n\n```kotlin\n// dispatches execution into Android main thread\nval uiDispatcher: CoroutineDispatcher = Dispatcher.Main\n\n// represent a pool of shared thread as coroutine dispatcher\nval bgDispatcher: CoroutineDispatcher = Dispatcher.IO\n```\n\n### 协程作用域\n\n使用协程需要提供协程对应的作用域CoroutineScope或使用GlobalScope\n\n```kotlin\n// GlobalScope示例\nclass MainFragment : Fragment(){\n    fun loadData() = GlobalScope.launch{...}\n}\n\n//CoroutineScope示例\nclass MainFragment : Fragment(){\n    \n    val uiScope = CoroutineScope(Dispatchers.Main)\n    \n    fun loadData() = uiScope.launch{...}\n}\n\n//Fragment实现CoroutineScope示例\nclass MainFragment : Fragment(),CoroutineScope{\n    \n    override val coroutineContext: CoroutineContext\n    \tget() = Dispatcher.Main\n    \n    fun loadData() = launch {...}\n}\n```\n\n### lauch+async(执行任务)\n\n父协程通过Main Dispatcher调用的launch方法启动。\n\n子协程通过IO Dispatcher调用async方法启动。\n\n*Note：父协程会一直等待它的子协程完成*\n\n*Note：协程如果发生未捕获异常，程序会崩溃*\n\n```kotlin\nval uiScope = CoroutineScope(Dispatchers.Main)\n\nfun loadData() = uiScope.launch {\n    view.showLoading()\t//ui thread\n\n\tval task = async(bgDispatcher){\t//background thread\n    \t// your blocking call\n\t}\n\tval result = task.await()\n\n\tview.showDta()\n}\n```\n\n### lauch+withContext(执行任务)\n\n使用上一个例子中的方法，我们可以正常的运行。但我们浪费了启用第二个后台任务协程的资源。\n\n如果我们只启用一个协程，可以使用withContext来优化我们的代码。\n\n后台任务通过带有IO Dispatcher的withContext函数执行。\n\n```kotlin\nval uiScope = CoroutineScope(Dispatcher.Main)\n\nfun loadData() = uiScope.launch {\n    view.showLoading()\t//ui thread\n    \n    val result = withContext(bgDispatcher){\n        // your blocking call\n    }\n    \n    view.showData(result)\t// ui thread\n}\n```\n\n### launch+ withContext(按顺序执行两个任务)\n\n```kotlin\nval uiScope = CoroutineScope(Dispatchers.Main)\n\nfun loadData() = uiScope.launch {\n    view.showLoading()\t// ui thread\n    \n    val result1 = withContext(bgDispatcher){\n        // your blocking call\n    }\n    \n    val result2 = withContext(bgDispatcher){\n        //your blocking call\n    }\n    \n    val result = result1 + result2\n    \n    vuew,showData(result)\t//ui thread\n}\n```\n\n### launch+async+async(并行执行两个任务)\n\n```kotlin\nval uiScope = CoroutineScope(Dispatcher.Main)\n\nfun loadData() = uiScope.launch {\n    view.showLoading()\t// ui thread\n    \n    val task1 = async(bgDispatcher){\n        //your blocking call\n    }\n       \n    val task2 = async(bgDispatcher){\n        //your blocking call\n    }\n    \n    val result = task1.await() + task2.await()\n   \tview.showData()\t// ui thread\n}\n```\n\n## 二、如何使用协程的timeout\n\n如果我们想为一个协程任务设置超时，我们可以使用withTimeoutOrNull()方法，如果超时就返回null。\n\n```kotlin\nval uiScope = CoroutineScope(Dispatchers.Main)\n\nfun loadData() = uiScope.launch {\n    view.showLoading()\t// ui thread\n    \n    val task = async(bgDispatcher){\n        //your blocking call\n    }\n    \n    // suspend until task is finished or return null in 2s\n    val result = withTimeoutOrNull(2000) { task.await() }\n    \n    view.showData(result)\t// ui thread\n}\n```\n\n## 三、如何取消一个协程\n\n### 3.1 job\n\nloadData()方法返回一个Job对象，Job对象是可以被取消的。当父协程被取消的时候，它的所有子协程都会被结束。当stopPresenting()方法被调用，view.showData()肯定不会被调用。\n\n```kotlin\nval uiScope = CoroutineScope(Dispatchers.Main)\nval job: Job? = null\n\nfun startPresenting(){\n    job = loadData()\n}\n\nfun stopPresenting(){\n    job?.cancel()\n}\n\nfun loadData() = uiScope.launch {\n    view.showLoading()\t// ui thread\n    \n    val result = withContext(bgDispatcher){\n        // your blocking call\n    }\n    \n    view.showData(result)\t//ui thread\n}\n```\n\n### 3.2 parent job\n\n取消协程的另一种方法是创建SupervisorJob对象，并通过重载+运算符在作用域构造函数中指定它。\n\n```kotlin\nvar job = SipervisorJob()\nval uiScope = CoroutineScope(Dispatchers.Main + job)\n\nfun startPresenting(){\n    loadData()\n}\n\nfun stopPresenting(){\n    scope.coroutineContext.cancelChildren()\n}\n\nfun loadData() = uiScope.launch {\n\tview.showLoading()\n    \n    val result = withContext(bgDispatcher) {\n        // your blocking call\n    }\n    \n    view.showData(result)\n}\n```\n\n### 3.3 自定义具有生命周期感知的协程作用域\n\n```kotlin\nclass MainScope : CoroutineScope, LifecycleObsever {\n    private val job = SupervisorJob()\n    override val coroutineContext: CoroutineContext\n    \tget() = job + Dispatchers.Main\n    \n    @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)\n    fun destory() = coroutineContext.cancelChildren()\n}\n\n//使用\nclass MainFragment : Fragment(){\n    private val uiScope = MainScope()\n    \n    override fun onCreate(savedInstanceState: Bundle?){\n        super.onCreate(savedInstanceState)\n        lifecycle.addObserver(mainScope)\n    }\n    \n    private fun loadData() = uiScope.launch {\n        val result = withContext(bgDispatcher) {\n\t\t\t// your blocking call\n        }\n    }\n}\n```\n\n下面，举一个在ViewModel中使用生命周期感知的协程。\n\n```kotlin\nopen class ScopedViewModel : ViewModel(){\n    \n    private val job = SupervisorJob()\n    protected val uiScope = CoroutineScope(Dispathcers.Main + job)\n    \n    override fun onCleared(){\n        super.onCleared()\n        uiScope.coroutineContext.cancelChildren()\n    }\n}\n\n//使用\nclass MyViewModel : ScopedViewModel(){\n    private fun loadData() = uiScope.launch {\n        val result = withContext(bgDispatcher) {\n            // your blocking call\n        }\n    }\n}\n```\n\n## 四、如何处理协程中的异常\n\n### 4.1 try-catch\n\n我们可以使用try-catcher捕获并处理异常\n\n```kotlin\nprivate fun loadData() = GlobalScope.launch(uiDispatcher) {\n    view.showLoading()\n    \n    try {\n        val result = withContext(bgDispatcher) { dataProvider.loadData() }\n        view.showData(result)\n    } catch(e: Exception){\n        e.printStackTrace()\n    }\n}\n```\n\n为了避免在Presenter中使用try-catch，最好在dataProvider.loadData()函数中处理异常并使其返回通用Result类。\n\n```kotlin\ndata class Result\u003cout T\u003e(val success: T? = null,\n                        val error: Throwable? = null)\n\nprivate fun loadData() = launch(uiContext){\n    view.showLoading()\n    \n    val task = async(bgContext) { dataProvider.loadData(\"Task\") }\n    val result: Result\u003cString\u003e = task.await()\n    \n    if(result.success != null){\n        view.showData(result.success)\n    } else if(result.error != null){\n        result.error.printStackTrace()\n    }\n}\n```\n\n### 4.2 async parent\n\n使用async启动父协程来忽视异常。\n\n```kotlin\nprivate fun loadData() = GlobalScope.async(uiDispatcher) {\n    view.showLoading()\n    \n    val result = withContext(bgDispatcher) { dataProvider.loadData() }\n    \n    view.showData(result)\n}\n```\n\n使用这种方法， 异常会被保存在job对象中。我们可以使用invokeOnCompletion()方法来取回它。\n\n```kotlin\nvar job: Job? = null\n\nfun startPresenting() {\n    job = loadData()\n    job?.invokeOnCompletion { it: Throwable? -\u003e\n    \tit?.printStackTrace()\n        job?.getCompletionException()?.printStackTrace()\n    }\n```\n\n### 4.3 launch + coroutine exception handler\n\n你可以将CoroutineExceptionHandler添加到父协同程序上下文以捕获异常并处理它们。\n\n```kotlin\nval exceptionHandler: CoroutineContext = CoroutineExceptionHandler {\n    -, throwable-\u003e \n    \tview.showData(throwable.message)\n    \tjob = Job()                                                            \n}\n\nprivate fun loadData() = GlobalScope.async(uiDispatcher + exceptionHandler){\n    view.showLoading()\n    \n    val result = withContext(bgDispatcher) { dataProvider.loadData() }\n    \n    view.showData(result)\t//如果发生异常就不会被调用\n}\n```\n\n## 五、如何测试协程\n\n启动一个协程需要你指定一个CoroutineDispatcher。\n\n```kotlin\nclass MainPresenter(val view: MainView,\n                   val dataProvider: DataProviderAPI) {\n    \n    private fun loadData() = GlobalScope.launch(Dispacthers.Main){\n        view.showLoading()\n        \n        val result = withContetx(Dispatchers.IO) { dataProvider.loadData() }\n        \n        view.showData(result)\n    }\n}\n```\n\n如果你想为上面的MainPresenter编写一个单元测试，你可能需要指定一个协程context用于ui和background执行。\n\n可能最简单的方法是向MainPresenter构造函数添加两个参数：uiDispatcher，默认值为Main，ioContext，默认值为IO。\n\n```kotlin\nclass MainPresnter(val view: MainView,\n                  val dataProvider: DataProviderAPI,\n                  val uiDispatcher: CoroutineDispatcher = UI,\n                  val ioDispatcher: CoroutineDispatcher = IO){\n    \n    private fun loadData() = GlobalScope.launch(uiDispatcher) {\n        view.showLoading()\n        \n        val result = withContext(ioDispatcher) { dataProvider.loadData() }\n        view.showData(result)\n    }\n}\n```\n\n现在，您可以通过提供Unconfined来轻松测试您的MainPresenter类，它只会在当前线程上执行代码。\n\n```kotlin\n@Test\nfun startPresenting(){\n    //given\n\tval view = mock(MainView::class.java)\n    val dataProvider = mock(DataProviderAPI::class.java)\n    \n    val presenter = MainPresenter(view,\n                                 dataProvider,\n                                 Dispatcher.Unconfined,\n                                 Dispacther.Unconfined)\n    \n    //when\n    presenter.startPresenting()\n    \n    //then\n}\n```\n\n## 六、如何实现协程线程日志\n\n要了解哪个协同程序执行当前工作，可以通过System.setProperty打开调试工具并通过Thread.currentThread().name来记录线程名称。\n\n```kotlin\n//调式模式\nSystem.setProperty(\"kotlinx.coroutines.debug\", if(BuildConfig.DEBUG) \"on\" else \"off\")\n\nlaunch(UI) {\n    log(\"Data loading started\")\n    \n    val task1 = async { log(\"Hello\") }\n    val task2 = async { log(\"World\") }\n    \n    val result = task1.await() + task2.await()\n    \n    log(\"Data loading completed: $result\")\n}\n\nfun log(msg: String){\n    Log.d(TAG， \"[${Thread.currentThread().name}] $msg\")\n}\n```","created_by":"Jotyy","modified_by":""},{"ID":17,"CreatedAt":"2019-07-11T09:13:55+08:00","UpdatedAt":"0001-01-01T00:00:00Z","DeletedAt":null,"title":"Android协程——Room \u0026 Coroutines","cover_url":"https://jotyy.top/images/5.jpg","desc":"","content":"在Room2.1版本中提供了对协程的支持。Dao层的方法可以被suspend标记来确保他们在主线程中被执行。接下来，我们就来看看如何使用并为它写一个简单的单元测试。\n\n## 为你的数据库加点suspending\n\n首先我们要为项目加上Room的依赖，并确保版本在2.1及以上。\n\n```gr\nimplementation \"androidx.room:room-coroutines:${versions.room}\"\n```\n\n同时，我们的还需要Kotlin版本在1.3.0以上，以及Coroutines 1.0.0以上。\n\n接下来我们可以编写如下的DAO层，使用suspend标记方法。\n\n```kotlin\n@Dao\ninterface UsersDao{\n    @Query\n    suspend fun getUsers(): List\u003cUser\u003e\n    \n    @Query\n    suspend fun incrementUserAge(userId: String)\n    \n    @Insert\n    suspend fun insertUser(user: User)\n    \n    @Update\n    suspend fun updateUser(user: User)\n    \n    @Delete\n    suspend fun deleteUser(user: User)\n}\n```\n\n被@Transacition注解的方法也可以使用suspend关键字标记，并且可以调用其他被suspend标记的DAO层方法。\n\n```kotlin\n@Dao\nabstract class UsersDao{\n    @Transaction\n    open suspend fun setLoggedInUser(loggerInUser: User){\n\t\tdeleteUser(loggedInUser)\n        insertUser(loggedInUser)\n    }\n    \n    @Query(\"DELETE FROM users\")\n    abstract fun deleteUser(user: User)\n\n\t@Insert\n    abstract suspend fun insertUser(user: User)\n}\n```\n\n同样，你也可以从不同的DAO中调用suspend方法。\n\n```kotlin\nclass Repository(val database: MyDatabase) {\n    \n    suspend fun clearData(){\n        database.withTransaction {\n            database.userDao().deleteLoggerInUser()\n            database.commentsDao().deleteComments()\n        }\n    }\n}\n```\n\n你可以在创建数据库时通过调用setTransactionExecutor()方法或setQueryExecutor()方法来提供executors去控制它们运行的线程。默认情况下，这将是用于在后台线程上运行查询的相同执行程序。\n\n## 编写单元测试\n\n测试DAO suspend方法和测试其它的suspend方法是一样的。例如，要检查插入用户后我们能够检索它，我们将测试包装在runBlocking块中：\n\n```kotlin\n@Test\nfun insertAndGetUser() = runBlocking {\n    //提供一个插入到数据库中的User\n    userDao.insertUser(user)\n    \n    // 通过DAO获取Users\n    val usersFromDb = userDao.getUsers()\n    \n    //验证\n    assertEquals(listOf(user), userFromDb)\n}\n```\n\n## 再深入一点去看\n\n进一步，让我们来看看为同步和暂停插入生成的DAO类实现：\n\n```kotlin\n@Insert\nfun insertUserSync(user: User)\n\n@Insert\nsuspend fun insertUser(user: User)\n```\n\n在同步插入的方式中，生成的代码启动事务，执行插入，将事务标记为成功并结束它。同步方法只在任何调用它的线程上的执行insert。\n\n```java\n@Override \npublic void insertUserSync(final User user) {\n    _db.beginTransaction();\n    try{\n        _insertionAdapterOfUser.insert(user);\n        _db.setTransactionSuccessful();\n    } finally {\n        _db.endTransaction();\n    }\n}\n```\n\n我们再来看看使用suspend关键字的方法是如何处理的。\n\n```java\n@Override\npublic Object insertUserSuspend(final User user,\n                               final Continuation\u003c? super Unit\u003e p1){\n    \n    return CoroutinesRoom.execute(_db,new Callable\u003cUnit\u003e(){\n        @Override\n        public Unit call() throws Exception {\n            _db.beginTransaction();\n            try {\n\t\t\t\t_insertionAdapterOfUser.insert(user);\n                _db.setTransactionSuccessful();\n                return kotlin.Unit.INSTANCE;\n            } finally {\n\t\t\t\t_db.endTransaction();\n            }\n        }\n    }, p1);\n}\n```\n\n生成的代码中确保了插入不发生在UI线程上。在我们的suspend函数实现中，同步insert方法中的相同逻辑包含在`Callable`中。Room调用`CoroutinesRoom.execute`挂起函数，该函数切换到后台调度程序，具体取决于数据库是否已打开且我们是否处于事务中。这是函数的实现：\n\n```kotlin\n@JvmStatic\nsuspend fun \u003cR\u003e execute(\n\tdb: RoomDatabase,\n    inTransaction: Boolean,\n    callable: Callable\u003cR\u003e\n): R {\n    if (db.isOpen \u0026\u0026 db.inTransaction) {\n        return callable.call()\n    }\n    \n    val context = coroutineContext[TransactionElement]?.transactionDispatcher\n    \t?: if (inTransaction) db.transactionDispatcher else db.queryDispatcher\n    return withContext(context) {\n        callable.call()\n    }\n}\n```\n\n**情形一：数据库打开，且我们在事务中**\n\n此时我们直接执行callable即可\n\n**情形二：其他**\n\nRoom确保Callable中的工作已完成（call方法在后台执行）。\n\nRoom会使用不同的dispatcher来处理事务和查询。这些是从构建数据库时提供的执行程序派生的，或者默认情况下将使用系统组件IO执行程序，这和LiveData执行后台任务的executor是一样的。\n\n在应用程序中开始使用Room和coroutines，保证数据库工作在非UI Dispatcher上运行。使用suspend修饰符标记您的DAO方法，并从其他挂起函数或协程中调用它们！","created_by":"Jotyy","modified_by":""},{"ID":18,"CreatedAt":"2019-07-13T12:32:42+08:00","UpdatedAt":"0001-01-01T00:00:00Z","DeletedAt":null,"title":"RxJava —— 响应式编程的魅力","cover_url":"https://jotyy.top/images/4.jpg","desc":"","content":"[TOC]\n\nRxJava可以说是众多Android开发者的噩梦了，因为它的入门门槛极高，导致很多人望而却步。但如果你 开始明白它的原理之后，真的会使你沉迷其中。\n\nRxJava2是对RxJava的完全重新，因此两者的区别很大，现在我们普遍使用的都是RxJava2。学习RxJava2需要对响应式编程有一个正确的理解。\n\n这篇文章，我主要目标是要深入了解RxJava的响应式编程的基础知识和各种核心概念，并结合一些现实的例子，使它们的概念更加清晰明了，易于使用。\n\n## Android的异步世界\n\n我们在Android程序的编写过程中，不可避免的会遇到各种各样的异步问题。比如说你需要读取/写入数据到本地磁盘，你需要等待一段时间才能完成操作。\n\n另外，当你进行网络请求从服务器获取数据的时候，也会遇到类似的情况，网络请求不是实时完成的，需要几毫秒到几秒的时间去响应。\n\n再深入去思考一下的话，你会发现Android的整个用户输入机制本质上就是**异步**的。Android设备持续等待用户的输入，比如触摸、滑动等动作，并相应地对这些输入做出响应。\n\n## 什么是响应式呢\n\n现在我们知道——从数据库事务、文件操作、网络请求到复杂计算、用户输入、推送通知，几乎所有的Android操作都是异步的。\n\n**因此，**为什么我们在以同步的方式努力去构建程序，而在应用程序中最终运行的世界却是如此异步的？\n\n在开始编写程序之前，这难道不是沃恩首先要问自己的问题吗？\n\n难道我们不应该考虑使用更好的方法使我们的开发工作变得更加简单吗？\n\n**所以，让我们用响应式的方式来思考。**\n\n由于我们大多数人在多数情况下都在以一种必要的方式去思考和编写代码，因此很难做出这么巨大的思想转变，但我们可以试着从RxJava的学习开始。响应式编程并不难，它只是思考的方式不同。\n\n因此，在学习的过程中，我们首先考虑专注于基础知识和核心概念，试着考虑可以充分利用它们的场景，在遇到困难时，提醒自己尽可能需要改变思考或解决问题的方式。\n\n**响应式编程和命令式编程在根本上是不同的。**\n\n------------\n\n\n\n## 响应式编程的优势\n\n在Android的RxJava可以为我们带来相当多的好处。\n\n### 处理多线程\n\n多线程在Java中是非常难的一个知识点，我们经常会在处理多线程的过程中写出Bug。但是RxJava可以简单方便的执行复杂的线程操作，保持同步并将结果传递到UI线程。\n\n### 消除烦人的回调\n\n当我们需要执行多个异步操作，而且每个操作都取决于上一步操作的结果时，我们就会不知不觉的深陷的回调的泥潭中，后来我们想要理解和维护这样的代码就会变得异常困难。\n\n而通过响应式编程，我们可以轻松地消除这种情况，写出干净、简洁可维护的代码。\n\n### 错误处理变得轻而易举\n\n在现实生活中，不可能永远是晴天，总有下雨的时候。在写代码的过程中，也不可能永远都是没有错误的，特别是处理网络、数据库、文件的时候，时常会报错。\n\nRxJava强大的错误处理机制，可以让我们非常方便的处理错误发生的情况。\n\n### 各种操作符\n\n响应式编程的另一个强大之处就是各种强大的操作符，它们可以帮我们方便的处理一些常见的事务。\n\n### 更少的代码，更少的Bug\n\n使用响应式编程写出的程序，往往可读性更强，容易理解。你会发现你写的代码少了很多，但是错误缺很少，更加稳定。\n\n------------\n\n\n\n## 开始讨论RxJava\n\n简单来说，响应式编程时消费者在数据到达时做出反应的范例，也是观察者模式的一种完美实现。RxJava就是响应式编程在Java领域的实现。\n\n### RxJava 的三个O\n\n#### Observable\n\nObservable代表被观察者，作为希望被观察的数据源。\n\n假设你参加了一个会议。发言者有一个你感兴趣的人。你一讲这个发言者视为Observable，他可以不断的为你提供数据流或其它内容供你消费。\n\n##### Hot vs Cold Observable\n\n我们可以让Observable只在有人订阅的时候发出数据，像发言者一样，除非有听众，否则他不会一个人高谈阔论。这可以被称作：Cold Observable\n\n我们也可以使Observable即使没人订阅他，也可以发出数据。就像有时候会议开始时人还没来，发言者也照样开始了演说，与会者一个个的加入，然后从那时开始听他说话。这就是Hot Observable。\n\n在Android中，一个cold Observable可以是一个没人订阅就不会发出数据的网络请求。除非有人订阅了，Observable才发起网络请求，获取数据并发送给subscriber。\n\n一个Hot Observable，可以是一个位置更新的事件流，位置更新会持续发生，即使没有订阅。\n\n##### Get，Set，Code\n\n```java\nObservable\u003cMovie\u003e movieObservable = remoteService.getMovies();\n```\n\nObservable可以提供从网络数据源获取的Movie。它可以是一个或多个数据。如果Observable无法获取数据，他将提示一个错误。","created_by":"Jotyy","modified_by":""}]}

